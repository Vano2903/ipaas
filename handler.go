package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"time"

	"github.com/gorilla/sessions"
	resp "github.com/vano2903/ipaas/responser"
)

type Handler struct {
	cc   *ContainerController
	sess *sessions.CookieStore
}

func (h Handler) GetUserFromCookie(r *http.Request, connection *sql.DB) (Student, error) {
	var acc string
	for _, cookie := range r.Cookies() {
		switch cookie.Name {
		case "accessToken":
			acc = cookie.Value
		}
	}

	if acc == "" {
		return Student{}, fmt.Errorf("no access token found")
	}

	fmt.Println("access Token found from get user from cookie:", acc)

	s, err := GetUserFromAccessToken(acc, connection)
	if err != nil {
		return Student{}, err
	}

	return s, nil
}

func (h Handler) NewTokenPairFromRefreshTokenHandler(w http.ResponseWriter, r *http.Request) {
	db, err := connectToDB()
	if err != nil {
		resp.Error(w, http.StatusInternalServerError, err.Error())
		return
	}
	defer db.Close()

	//get the refresh token from the cookie
	cookie, err := r.Cookie("refreshToken")
	if err != nil {
		if err == http.ErrNoCookie {
			resp.Error(w, http.StatusBadRequest, "No refresh token")
			return
		}
		resp.Error(w, http.StatusInternalServerError, err.Error())
		return
	}
	refreshToken := cookie.Value
	log.Println("refresh token found:", refreshToken)

	if refreshToken == "" {
		resp.Error(w, http.StatusBadRequest, "No refresh token")
		return
	}

	//check if the refresh token is expired
	if IsTokenExpired(false, refreshToken, db) {
		//!should redirect to the oauth page
		resp.Error(w, http.StatusBadRequest, "Refresh token is expired")
		return
	}

	//generate a new token pair
	accessToken, newRefreshToken, err := GenerateNewTokenPairFromRefreshToken(refreshToken, db)
	if err != nil {
		resp.Error(w, http.StatusInternalServerError, err.Error())
		return
	}

	//delete the old tokens from the cookies
	http.SetCookie(w, &http.Cookie{
		Name:    "accessToken",
		Path:    "/",
		Value:   "",
		Expires: time.Unix(0, 0),
	})
	http.SetCookie(w, &http.Cookie{
		Name:    "refreshToken",
		Path:    "/",
		Value:   "",
		Expires: time.Unix(0, 0),
	})

	//!should set domain and path
	http.SetCookie(w, &http.Cookie{
		Name:    "accessToken",
		Path:    "/",
		Value:   accessToken,
		Expires: time.Now().Add(time.Hour),
	})
	http.SetCookie(w, &http.Cookie{
		Name:    "refreshToken",
		Path:    "/",
		Value:   newRefreshToken,
		Expires: time.Now().Add(time.Hour * 24 * 7),
	})

	response := map[string]interface{}{
		"accessToken":  accessToken,
		"refreshToken": newRefreshToken,
	}
	resp.SuccessParse(w, http.StatusOK, "New token pair generated", response)
}

//check if the user has a valid access Token
func (h Handler) TokensMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		log.Println("tokens middleware")
		// get the access token and the refresh token from cookies

		var accessToken string
		var refreshToken string
		for _, cookie := range r.Cookies() {
			switch cookie.Name {
			case "accessToken":
				accessToken = cookie.Value
			}
		}

		//create a connection with the db
		db, err := connectToDB()
		if err != nil {
			resp.Error(w, http.StatusInternalServerError, err.Error())
			return
		}
		defer db.Close()
		//check if the refresh token is expired
		if IsTokenExpired(false, refreshToken, db) {
			//!should redirect to the oauth page
			resp.Error(w, http.StatusBadRequest, "Refresh token is expired")
			return
		}

		//check if the access token is found and valid
		if accessToken == "" || IsTokenExpired(true, accessToken, db) {
			var newRefreshToken string
			//generate a new token pair
			accessToken, newRefreshToken, err = GenerateNewTokenPairFromRefreshToken(refreshToken, db)
			if err != nil {
				resp.Error(w, http.StatusInternalServerError, err.Error())
				return
			}

			//delete the old tokens from the cookies
			http.SetCookie(w, &http.Cookie{
				Name:    "accessToken",
				Path:    "/",
				Value:   "",
				Expires: time.Unix(0, 0),
			})
			http.SetCookie(w, &http.Cookie{
				Name:    "refreshToken",
				Path:    "/",
				Value:   "",
				Expires: time.Unix(0, 0),
			})

			//set the new tokens as cookie
			//!should set domain and path
			http.SetCookie(w, &http.Cookie{
				Name:    "accessToken",
				Path:    "/",
				Value:   accessToken,
				Expires: time.Now().Add(time.Hour),
			})
			http.SetCookie(w, &http.Cookie{
				Name:    "refreshToken",
				Path:    "/",
				Value:   newRefreshToken,
				Expires: time.Now().Add(time.Hour * 24 * 7),
			})
		}
		w.Header().Set("content-type", "application/json")
		w.Write([]byte(""))

		//redirect to the actual handler
		next.ServeHTTP(w, r)
	})
}

//! still under development
//new database handler, let the user create a new database given the default db name (can be null)
//credentials will be autogenerated
//the body should contain:
//1) db name
//2) db type (mysql, mariadb, mongodb)
//3) (not implemented) db version (can be null which will mean the latest version)
func (h Handler) NewDBHandler(w http.ResponseWriter, r *http.Request) {

	//connect to the db
	conn, err := connectToDB()
	if err != nil {
		resp.Errorf(w, http.StatusInternalServerError, "error connecting to the database: %v", err.Error())
		return
	}
	defer conn.Close()
	//get the student from the cookies
	student, err := h.GetUserFromCookie(r, conn)
	if err != nil {
		resp.Errorf(w, http.StatusInternalServerError, "error getting the user from cookies: %v", err.Error())
		return
	}

	fmt.Println("student: ", student)

	//read post body
	var dbPost dbPost
	err = json.NewDecoder(r.Body).Decode(&dbPost)
	if err != nil {
		resp.Errorf(w, http.StatusBadRequest, "error decoding the json: %v", err.Error())
		return
	}

	//generate env variables for the container
	password := generateRandomString(16)
	var env []string
	switch dbPost.DbType {
	case "mysql", "mariadb":
		env = []string{
			"MYSQL_ROOT_PASSWORD=" + password,
		}
		if dbPost.DbName != "" {
			env = append(env, "MYSQL_DATABASE="+dbPost.DbName)
		}
	case "mongodb":
		env = []string{
			"MONGO_INITDB_ROOT_USERNAME=" + "root",
			"MONGO_INITDB_ROOT_PASSWORD=" + password,
		}
		if dbPost.DbName != "" {
			env = append(env, "MONGO_INITDB_DATABASE="+dbPost.DbName)
		}
	default:
		resp.Error(w, http.StatusBadRequest, "Invalid db type, must be mysql, mariadb or mongodb")
		return
	}

	//create the database container
	id, err := h.cc.CreateNewDB(h.cc.dbContainersConfigs[dbPost.DbType], env)
	if err != nil {
		resp.Errorf(w, http.StatusInternalServerError, "error creating a new database: %v", err.Error())
		return
	}

	//get the external port
	port, err := h.cc.GetContainerExternalPort(id, h.cc.dbContainersConfigs[dbPost.DbType].port)
	if err != nil {
		resp.Errorf(w, http.StatusInternalServerError, "error getting the external port: %v", err.Error())
		return
	}

	//add a new database application created by the student (student id)
	insertApplicationQuery := `
	INSERT INTO applications (containerID, status, studentID, type, name, description) VALUES (?, ?, ?, ?, ?, ?)
	`

	_, err = conn.Exec(insertApplicationQuery, id, "up", student.ID, "database", fmt.Sprintf("%d:%s/%s", student.ID, dbPost.DbType, dbPost.DbName), "")
	if err != nil {
		resp.Errorf(w, http.StatusInternalServerError, "unable to link the application to the user: %v", err.Error())
		return
	}

	json := make(map[string]interface{})

	json = map[string]interface{}{
		"important": "the password is for root user of the server",
		"user":      "root",
		"port":      port,
		"pass":      password,
	}
	if dbPost.DbType == "mongodb" {
		json["uri"] = fmt.Sprintf("mongodb://root:%s@%s:%s", password, "127.0.0.1", port)
	}
	resp.SuccessParse(w, http.StatusOK, "New DB created", json)
}

//oauth handler, will handle the 2 steps of the oauth process
func (h Handler) OauthHandler(w http.ResponseWriter, r *http.Request) {
	//connect to the db
	db, err := connectToDB()
	if err != nil {
		resp.Error(w, http.StatusInternalServerError, err.Error())
		return
	}
	defer db.Close()
	session, _ := h.sess.Get(r, "ipaas-session")
	//read url parameters
	parameters := r.URL.Query()
	UrlCode, okCode := parameters["code"]
	UrlState, okState := parameters["state"]

	//check if a paleoid access token is stored in the session
	if session.Values["paleoidAccessToken"] != nil {
		paleoIDAccessToken := session.Values["paleoidAccessToken"].(string)
		//register the user (if not alreayd registered) from the access token and generate a token pain
		response, isClientSide, err := registerOrGenerateTokenFromPaleoIDAccessToken(paleoIDAccessToken, db)
		if err != nil {
			if isClientSide {
				resp.Error(w, http.StatusBadRequest, err.Error())
			} else {
				resp.Error(w, http.StatusInternalServerError, err.Error())
			}
			return
		}
		//save the tokens in the session
		//set the tokens as cookie
		//!should set domain and path
		http.SetCookie(w, &http.Cookie{
			Name:    "accessToken",
			Value:   response["accessToken"].(string),
			Expires: time.Now().Add(time.Hour),
		})
		http.SetCookie(w, &http.Cookie{
			Name:    "refreshToken",
			Value:   response["refreshToken"].(string),
			Expires: time.Now().Add(time.Hour * 24 * 7),
		})
		resp.SuccessParse(w, http.StatusOK, "Token generated", response)
		return
	}

	//check if it's the second phase of the oauth
	if okCode && okState {
		//check if the state is valid (rsa envryption)
		valid, err := CheckState(UrlState[0])
		if err != nil {
			resp.Error(w, http.StatusInternalServerError, err.Error())
			return
		}
		if !valid {
			resp.Error(w, http.StatusBadRequest, "Invalid state")
			return
		}

		//get the paleoid access token
		paleoidAccessToken, err := GetPaleoIDAccessToken(UrlCode[0])
		if err != nil {
			resp.Error(w, http.StatusInternalServerError, err.Error())
			return
		}

		//use this paleoid to generate a token pair and save the user on the db in case he is not already registered
		response, isClientSide, err := registerOrGenerateTokenFromPaleoIDAccessToken(paleoidAccessToken, db)
		if err != nil {
			if isClientSide {
				resp.Error(w, http.StatusBadRequest, err.Error())
			} else {
				resp.Error(w, http.StatusInternalServerError, err.Error())
			}
			return
		}
		//save the tokens in the session

		//!should set domain and path
		http.SetCookie(w, &http.Cookie{
			Name:    "accessToken",
			Value:   response["accessToken"].(string),
			Expires: time.Now().Add(time.Hour),
		})
		http.SetCookie(w, &http.Cookie{
			Name:    "refreshToken",
			Value:   response["refreshToken"].(string),
			Expires: time.Now().Add(time.Hour * 24 * 7),
		})
		resp.SuccessParse(w, http.StatusOK, "Token generated", response)
		return
	}

	//check if a server generated state is stored in the session
	if session.Values["state"] != nil {
		oauthUrl := fmt.Sprintf("https://id.paleo.bg.it/oauth/authorize?client_id=%s&response_type=code&state=%s&redirect_uri=%s", os.Getenv("OAUTH_ID"), session.Values["state"], os.Getenv("REDIRECT_URI"))
		// http.Redirect(w, r, oauthUrl, http.StatusFound)
		resp.Success(w, http.StatusOK, oauthUrl)
		return
	}
	//generate a new base64url encoded signed with rsa encrypted state (random string) and stored on the db (plain)
	state, err := CreateState()
	if err != nil {
		resp.Error(w, http.StatusInternalServerError, err.Error())
		return
	}
	//set the state on the session
	session.Values["state"] = state
	err = session.Save(r, w)
	if err != nil {
		log.Println(err)
		resp.Error(w, http.StatusInternalServerError, err.Error())
		return
	}

	oauthUrl := fmt.Sprintf("https://id.paleo.bg.it/oauth/authorize?client_id=%s&response_type=code&state=%s&redirect_uri=%s", os.Getenv("OAUTH_ID"), state, os.Getenv("REDIRECT_URI"))
	resp.Success(w, http.StatusOK, oauthUrl)
}

//get the user's informations from the ipaas access token
func (h Handler) LoginHandler(w http.ResponseWriter, r *http.Request) {
	log.Println("login handler")
	db, err := connectToDB()
	if err != nil {
		resp.Error(w, http.StatusInternalServerError, err.Error())
		return
	}
	defer db.Close()

	log.Println("getting access token")
	//get the accesstoken from the cookie
	cookie, err := r.Cookie("accessToken")
	if err != nil {
		if err == http.ErrNoCookie {
			resp.Error(w, http.StatusBadRequest, "No access token")
			return
		}
		resp.Error(w, http.StatusInternalServerError, err.Error())
		return
	}
	accessToken := cookie.Value
	log.Println("access token found:", accessToken)

	student, err := GetUserFromAccessToken(accessToken, db)
	fmt.Println("studente:", student)
	if err != nil {
		resp.Error(w, http.StatusInternalServerError, err.Error())
		return
	}

	studentByte, err := json.MarshalIndent(student, "", "  ")
	if err != nil {
		resp.Error(w, http.StatusInternalServerError, err.Error())
		return
	}
	resp.SuccessJson(w, http.StatusOK, "User", studentByte)
}

func NewHandler() (*Handler, error) {
	var h Handler
	var err error
	h.sess = sessions.NewCookieStore([]byte(os.Getenv("SESSION_KEY")))
	h.cc, err = NewContainerController()
	if err != nil {
		return nil, err
	}
	return &h, nil
}
