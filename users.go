package main

import (
	"database/sql"
	"errors"
	"fmt"
	"log"
	"time"
)

type Student struct {
	ID       int    `json:"matricola"` //id of the student (teachers will use the same but it's 6 digit long instead of 5)
	Name     string `json:"nome"`      //name of the student
	LastName string `json:"cognome"`   //last name of the student
	Email    string `json:"email"`     //email of the student
	Pfp      string `json:"pfp"`       //profile picture of the student (autogenerated)
}

//!currently unesed
type StudentInfo struct {
	Class               string `json:"classe"`
	Year                int    `json:"anno"`
	Field               string `json:"indirizzo"`
	IsClassPresident    bool   `json:"rappresentante_classe"`
	IsIstiturePresident bool   `json:"rappresentante_istituto"`
}

//get student struct from the id (matricola)
func GetStudentFromID(userID int, connection *sql.DB) (Student, error) {
	var student Student
	err := connection.QueryRow("SELECT * FROM student WHERE userID = ?", userID).Scan(
		&student.ID,
		&student.Name,
		&student.LastName,
		&student.Email,
	)
	if err != nil {
		return student, err
	}

	return student, nil
}

//check if the userUID is saved in the db
func IsUserRegistered(userID int, connection *sql.DB) (bool, error) {
	var registered int
	err := connection.QueryRow("SELECT userID FROM users WHERE userID = ?", userID).Scan(&registered)
	if err != nil {
		if err == sql.ErrNoRows {
			return false, nil
		}
		return false, err
	}

	return true, nil
}

//adds the student to the db (it's a pointer because here we generate the pfp)
func AddStudent(student *Student, connection *sql.DB) error {
	//check if it's already registered
	exists, err := IsUserRegistered(student.ID, connection)
	if err != nil {
		return err
	}
	if exists {
		return errors.New("user already registered")
	}

	student.Pfp = fmt.Sprintf("https://avatars.dicebear.com/api/bottts/%d.svg", student.ID)

	_, err = connection.Exec("INSERT INTO users (userID, name, lastName, email, pfp) VALUES (?, ?, ?, ?, ?)",
		student.ID,
		student.Name,
		student.LastName,
		student.Email,
		student.Pfp,
	)
	return err
}

//given the paleoid access token and the database connection, it returns the response that
//will be parsed into a json in the response, if the error is client side (4xx or 5xx) and an error
func registerOrGenerateTokenFromPaleoIDAccessToken(paleoidAccess string, connection *sql.DB) (map[string]interface{}, bool, error) {
	//get the student from the paleoid access token
	student, err := GetStudent(paleoidAccess)
	if err != nil {
		return nil, true, errors.New("invalid paleoid access token")
	}

	//check if it's in the db
	registered, err := IsUserRegistered(student.ID, connection)
	log.Printf("the user with %d is registered? %t ", student.ID, registered)
	if err != nil {
		return nil, false, err
	}

	//register the user if not already saved
	if !registered {
		log.Println("registering the user")
		err = AddStudent(&student, connection)
		if err != nil {
			return nil, false, err
		}
	}
	//generate the ipaas tokens
	access, refresh, err := GenerateTokenPair(student.ID, connection)
	if err != nil {
		return nil, false, fmt.Errorf("error generating token pair: %v", err)
	}

	//this map will be parsed into a json in the response
	resp := map[string]interface{}{
		"accessToken":  access,
		"refreshToken": refresh,
		"userID":       student.ID,
	}
	return resp, false, nil
}

type Application struct {
	ID          int       `json:"id"`
	ContainerID string    `json:"containerID"`
	Status      string    `json:"status"`
	StudentID   int       `json:"studentID"`
	Type        string    `json:type`
	Name        string    `json:"name"`
	Description string    `json:"description"`
	CreatedAt   time.Time `json:"createdAt"`
	IsPublic    bool      `json:"isPublic"`
}
